## Algorithm

점근표기법을 사용하는 이유 : 시간으로 이한 성능분석은 정확하지 않으므로 평균적인 성능분석을 위하여 점근표기법을 사용한다.

#### O(n) 빅오

O(n) : 최악의 경우의 성능을 나타낸다. 프로그램은 최악의 경우의 성능으로 많이 나타낸다.
Upper Bound : 상한선
0 <= f(n) <= Cg(n), n >= n0 일때 f(n) = O(g(n))이다
O(1), O(logn), O(n), O(nlogn), O(n^2), O(2^n), O(n!), O(n^n)
일반적으로 프로그램은 O(n^2) 까지 상한선으로 둔다.
서버프로그램은 O(nlogn)정도까지 허용한다.

O(1) : 해시테이블에서 find를 할때, Likedlist에서 insert를 할때
O(logn) : 2진 검색, 트리 검색, BST 등의 좋은 알고리즘 검색법들
O(n) : 배열을 검색한다. 특정한 정렬 알고리즘(정수, 문자), Insertion sort
O(nlogn) : 정렬 알고리즘(정렬 알고리즘은 nlogn 밑으로 떨어지지 않는다, 특수한 경우를 빼고)
O(n^2) : Join

#### Ω(n) 오메가

Ω(n) : 가장 빠를 경우의 성능을 나타낸다. 보통 운이 좋은 경우의 수이다. Lower Bound : 하한선
0 <= g(n) <= f(n), n >= n0

#### Θ(n) 세타

빅오와 오메가가 같은 경우의 성능을 나타낸다.
C1g(n) <= f(n) <= C2g(n)

#### Sort
Insertion Sort : n^2, 정렬되어 있는 경우에는 n
- 이미 정렬되어 있는 테이블에 원소를 추가하고 정렬할 경우에는 Insertion Sort를 선택하는게 좋다.
Quick Sort : nlogn
- pivot 값을 잘 뽑아야 성능이 좋다. 맨처음값, 중간값, 맨끝값 3개를 선택하고 그중에 중간값을 뽑아서 pivot값을 정한다.
